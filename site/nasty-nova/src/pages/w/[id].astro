---
import Base from '../../layouts/Base.astro';
import WordEntry from '../../components/WordEntry.astro';
import TagPills from '../../components/TagPills.astro';
import { getCollection } from 'astro:content';
import { related } from '../../lib/related';

export async function getStaticPaths() {
  const items = await getCollection('words');
  return items.map((it) => ({ params: { id: it.slug } }));
}

const { id } = Astro.params;
const all = await getCollection('words');
const item = all.find((x) => x.slug === id);
if (!item) {
  return Astro.redirect('/404');
}
const rel = related(item, all, 4);
const { Content } = await item.render();
---
<Base title={`${item.data['語']} - 存在しない辞典`}>
  {/** BUG-VARIANT: content-flagged (fallback to slug for dev without restart) */}
  {(item.data['バグ演出'] || item.slug === 'kuzuremoji') ? (
    <>
      <div class="buggy" data-mojibake={String(item.data['モジバケ演出'] ?? (item.slug === 'kuzuremoji'))}>
        <WordEntry item={item}>
          <TagPills tags={item.data['タグ']} />
          {/** Fake category injection: one impossible tag category line **/}
          <div class="meta fake-cat"><a class="pill odd" href={`/tags/${encodeURIComponent('？？？')}`}>？？？</a></div>
          <div class="divider"></div>
          <article class="entry-body">
            <Content />
            {/** ephemeral foreign back-meaning content (hidden; used for glitch) **/}
            <div id="foreign-back" class="sr-only">『横声（よこごえ）』の裏: 音は壁に向かって話す。返事は壁の内側から来る。</div>
          </article>
        </WordEntry>
      </div>
      {rel.length > 0 && (
        <section class="related related-wobble" style="margin-top:24px;">
          <h3>関連</h3>
          <ul>
            {rel.map((r, i) => (
              <li>
                <a href={i === 0 ? '/w/none' : `/w/${r.slug}`}>
                  {r.data['語']} [{r.data['読み']}]
                </a>
              </li>
            ))}
          </ul>
        </section>
      )}
      <style is:global>
        {`
        /* Scoped to this page via .buggy; trigger by adding .glitch-start */
        .buggy .entry-header .entry-title.glitch-start { position: relative; animation: titleHide 1400ms steps(2,end) 1 both; }
        @keyframes titleHide { 0% { color: transparent } 85% { color: transparent } 100% { color: var(--text) } }
        .buggy .entry-header .entry-title.glitching { color: transparent; }
        /* CSS-only fallback: overlay fake title that fades out */
        .buggy .entry-header .entry-title.glitch-start::before,
        .buggy .entry-header .entry-title.glitch-start::after {
          content: "";
          position: absolute; top: 0; left: 0; right: auto; bottom: auto; pointer-events: none; white-space: nowrap; z-index: 1; color: var(--text);
        }
        .buggy .entry-header .entry-title.glitch-start::before { content: "□□□"; opacity: 1; animation: titleMaskA 1400ms steps(2,end) 1 forwards; }
        .buggy .entry-header .entry-title.glitch-start::after  { content: "?";   opacity: 0; animation: titleMaskB 1400ms steps(2,end) 1 forwards; }
        @keyframes titleMaskA { 0% { opacity: 1 } 50% { opacity: 1 } 60% { opacity: 0 } 100% { opacity: 0 } }
        @keyframes titleMaskB { 0% { opacity: 0 } 50% { opacity: 0 } 60% { opacity: 1 } 90% { opacity: 1 } 100% { opacity: 0 } }
        /* subtle double-focus indicator (intentionally excessive) */
        .buggy :focus { outline: 2px solid var(--accent) !important; outline-offset: 1px; box-shadow: 0 0 0 2px rgba(77,119,255,0.25), 0 0 0 4px rgba(77,119,255,0.07) !important; }

        /* micro jitter on body text: letter/word spacing tremble */
        .buggy .entry-body { --j: 0.0px; letter-spacing: var(--j); word-spacing: calc(var(--j) * .6); }
        .buggy .entry-body.jitter { animation: jitter 3.8s steps(7, end) infinite; }
        @keyframes jitter {
          0%   { letter-spacing: 0px; }
          20%  { letter-spacing: 0.25px; }
          40%  { letter-spacing: 0.5px; }
          60%  { letter-spacing: 0.2px; }
          80%  { letter-spacing: 0.45px; }
          100% { letter-spacing: 0px; }
        }
        /* slight ghosting of some characters */
        .buggy .ghost { color: var(--muted); text-shadow: 1px 0 0 currentColor; }
        .buggy .double { position: relative; }
        .buggy .double::after { content: attr(data-ch); position: absolute; left: 1px; top: 0; opacity: 0.35; }

        /* transient mojibake tint so changes read as glitch, not content */
        .buggy .moji-glitch { filter: contrast(1.2) saturate(1.1); }

        /* Related wobble when at bottom */
        .related-wobble.wobble-on li { animation: shiver 1.1s infinite steps(2, end); transform-origin: 50% 50%; }
        @keyframes shiver { 0% { transform: translateY(-0.3px) } 50% { transform: translateY(0.4px) } 100% { transform: translateY(-0.3px) } }

        /* even under reduced motion, leave a trace */
        @media (prefers-reduced-motion: reduce) {
          .buggy .entry-body.jitter { animation-duration: 6.5s; }
          .related-wobble.wobble-on li { animation: shiver 2.8s infinite steps(2, end); }
        }

        /* Tag oddity styling */
        .buggy .fake-cat { margin-top: 6px; }
        .buggy .fake-cat .odd { border-color: #2a2f3a; color: #7d8290; }
        `}
      </style>
      <script>
document.addEventListener('DOMContentLoaded', function(){
  // Diagnostics
  console.debug('[kuzuremoji] script loaded');

  // Title glitch: trigger via IntersectionObserver
  var h1 = document.querySelector('.buggy .entry-title');
  function playOnce(){
    if (!h1) return;
    h1.classList.remove('glitch-start');
    void h1.offsetWidth; // reflow to restart animation if needed
    h1.classList.add('glitch-start');
    // Textual fallback so effect is visible even if CSS overlay misses
    var orig = h1.getAttribute('data-orig') || h1.textContent || '';
    h1.setAttribute('data-orig', orig);
    h1.textContent = '???';
    setTimeout(function(){ h1.textContent = '□□□'; }, 500);
    setTimeout(function(){ h1.textContent = orig; }, 1200);
    // auto-remove marker after animation to keep DOM tidy
    setTimeout(function(){ h1.classList.remove('glitch-start'); }, 1600);
  }
  if (h1) {
    var fired = false;
    var safety = null;
    var fireIfNeeded = function(){
      if (fired) return;
      fired = true;
      if (safety) { clearTimeout(safety); safety = null; }
      console.debug('[kuzuremoji] glitch play (immediate/fallback)');
      playOnce();
    };
    if ('IntersectionObserver' in window) {
      var seen = false;
      var io = new IntersectionObserver(function(entries){
        entries.forEach(function(e){
          if (!seen && e.isIntersecting && e.intersectionRatio > 0.5 && !fired) {
            seen = true; fired = true;
            if (safety) { clearTimeout(safety); safety = null; }
            console.debug('[kuzuremoji] glitch play (IO)');
            playOnce();
            io.disconnect();
          }
        });
      }, { threshold: [0, 0.5, 1] });
      io.observe(h1);
      // immediate check on load in case it's already in view but callback timing misses
      requestAnimationFrame(function(){
        var r = h1.getBoundingClientRect();
        var vh = window.innerHeight || document.documentElement.clientHeight;
        var vw = window.innerWidth || document.documentElement.clientWidth;
        var fullyOut = r.bottom <= 0 || r.right <= 0 || r.top >= vh || r.left >= vw;
        var halfVisible = !fullyOut && (Math.min(vh, Math.max(0, r.bottom)) - Math.max(0, r.top)) >= (r.height * 0.5);
        if (halfVisible) fireIfNeeded();
      });
      // safety timeout
      safety = setTimeout(fireIfNeeded, 1000);
    } else {
      // Fallback
      requestAnimationFrame(function(){ requestAnimationFrame(function(){ console.debug('[kuzuremoji] glitch play (no IO)'); playOnce(); }); });
    }
    // Manual replay for debug
    document.addEventListener('keydown', function(e){ if (e.key === 'g' || e.key === 'G') playOnce(); });
  } else {
    console.warn('[kuzuremoji] h1 not found');
  }

  // Activate micro jitter on content
  var body = document.querySelector('.entry-body');
  if (body) body.classList.add('jitter');

  // Randomly gray/double a few characters inside entry-body
  (function(){
    var root = body; if (!root) return;
    var walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
      acceptNode: function(n){ return (n.nodeValue && n.nodeValue.trim().length > 6) ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_REJECT; }
    });
    var nodes = []; var limit = 12; var n;
    while ((n = walker.nextNode()) && nodes.length < limit) nodes.push(n);
    nodes.forEach(function(t){
      var s = t.nodeValue || ''; if (!s) return;
      var i = Math.max(0, Math.min(s.length - 1, Math.floor(Math.random() * s.length)));
      var ch = s[i]; if (!ch || /\s/.test(ch)) return;
      var span = document.createElement('span');
      var cls = Math.random() < 0.5 ? 'ghost' : 'double';
      span.className = cls; span.setAttribute('data-ch', ch); span.textContent = ch;
      var before = document.createTextNode(s.slice(0, i));
      var after  = document.createTextNode(s.slice(i+1));
      var parent = t.parentNode; if (!parent) return;
      parent.insertBefore(before, t); parent.insertBefore(span, t); parent.insertBefore(after, t); parent.removeChild(t);
    });
  })();

  // 表の意味 paragraph truncation
  (function(){
    var hs = Array.prototype.slice.call(document.querySelectorAll('.entry-body h3'));
    var h = hs.find(function(el){ return /表の意味/.test(el.textContent || ''); });
    if (!h) return; var p = h.nextElementSibling; if (!p || p.tagName !== 'P') return;
    var full = p.textContent || ''; var cut = full.slice(0, Math.max(12, Math.floor(full.length * 0.55))) + '…'; p.textContent = cut;
  })();

  // Make 用例A and B repeat (same sentence)
  (function(){
    var quotes = Array.prototype.slice.call(document.querySelectorAll('.entry-body blockquote'));
    if (quotes.length >= 2) { var a = quotes[0].textContent || ''; quotes[1].textContent = a; }
  })();

  // details: on open, briefly flash a different word's back meaning
  (function(){
    var details = document.querySelector('.entry-body details');
    var foreign = document.getElementById('foreign-back');
    if (!details || !foreign) return;
    var summary = details.querySelector('summary');
    if (!summary) return;
    summary.addEventListener('click', function(){
      setTimeout(function(){
        var container = details;
        var kids = Array.prototype.slice.call(container.childNodes);
        var stash = document.createElement('div');
        kids.forEach(function(k){ if (k !== summary) stash.appendChild(k.cloneNode(true)); });
        var temp = document.createElement('div'); temp.textContent = foreign.textContent || '';
        kids.forEach(function(k){ if (k !== summary) container.removeChild(k); });
        container.appendChild(temp);
        setTimeout(function(){ container.removeChild(temp); container.appendChild(stash); }, 220);
      }, 40);
    });
  })();

  // Related wobble when scrolled to bottom
  (function(){
    var sec = document.querySelector('.related-wobble'); if (!sec) return;
    var onScroll = function(){ var atBottom = (window.innerHeight + window.scrollY) >= (document.body.scrollHeight - 2); sec.classList.toggle('wobble-on', atBottom); };
    window.addEventListener('scroll', onScroll, { passive: true }); onScroll();
  })();

  // Random transient mojibake: briefly corrupt random text nodes (feature-flagged)
  (function(){
    var root = document.querySelector('.buggy');
    if (!root) return;
    var enable = root.getAttribute('data-mojibake') === 'true';
    if (!enable) return;
    var GARBLE = ['□','？','※','〓','◇','▢','�','ﾊ','ﾂ','ｦ','｡','ﾟ','ﾞ'];
    var garbling = new WeakSet();
    var prefersReduced = false;
    try { prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches; } catch(e) {}

    function pickTextNodes(limit){
      var out = [];
      var walker = document.createTreeWalker(root, NodeFilter.SHOW_TEXT, {
        acceptNode: function(n){
          var v = n.nodeValue || '';
          if (garbling.has(n)) return NodeFilter.FILTER_REJECT;
          if (v.trim().length < 6) return NodeFilter.FILTER_REJECT;
          // avoid script/style or hidden
          var p = n.parentElement; if (!p || p.closest('script,style,code,pre')) return NodeFilter.FILTER_REJECT;
          return NodeFilter.FILTER_ACCEPT;
        }
      });
      var n; while ((n = walker.nextNode())) { out.push(n); if (out.length >= (limit||64)) break; }
      return out;
    }
    function randInt(a,b){ return a + Math.floor(Math.random()*(b-a+1)); }
    function garbleOnce(node){
      if (!node || garbling.has(node)) return;
      garbling.add(node);
      var orig = node.nodeValue || '';
      var idxs = [];
      for (var i=0;i<orig.length;i++){ if (!/\s/.test(orig[i])) idxs.push(i); }
      if (idxs.length === 0) { garbling.delete(node); return; }
      var start = idxs[randInt(0, idxs.length-1)];
      var len = Math.min(randInt(1,3), orig.length - start);
      var rep = '';
      for (var k=0;k<len;k++) rep += GARBLE[randInt(0, GARBLE.length-1)];
      var mutated = orig.slice(0,start) + rep + orig.slice(start+len);
      node.nodeValue = mutated;
      // brief lifetime then restore
      setTimeout(function(){ node.nodeValue = orig; garbling.delete(node); }, prefersReduced ? 320 : 520);
    }
    function tick(){
      var nodes = pickTextNodes(128);
      if (nodes.length === 0) return;
      // randomly pick 1–2 targets per tick
      var n = prefersReduced ? 1 : (Math.random()<0.35 ? 2 : 1);
      for (var i=0;i<n;i++) garbleOnce(nodes[randInt(0, nodes.length-1)]);
    }
    var interval = setInterval(tick, prefersReduced ? 2200 : 1300);
    // try first tick slightly after load
    setTimeout(tick, 600);
  })();
});
      </script>
    </>
  ) : (
    <>
      <WordEntry item={item}>
        <TagPills tags={item.data['タグ']} />
        <div class="divider"></div>
        <article class="entry-body">
          <Content />
        </article>
      </WordEntry>
      {rel.length > 0 && (
        <section style="margin-top:24px;">
          <h3>関連</h3>
          <ul>
            {rel.map((r) => (
              <li><a href={`/w/${r.slug}`}>{r.data['語']} [{r.data['読み']}]</a></li>
            ))}
          </ul>
        </section>
      )}
    </>
  )}
</Base>
